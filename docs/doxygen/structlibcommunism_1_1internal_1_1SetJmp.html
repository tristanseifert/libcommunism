<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcommunism: libcommunism::internal::SetJmp Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcommunism
   </div>
   <div id="projectbrief">Userspace cooperative threading library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcommunism.html">libcommunism</a></li><li class="navelem"><a class="el" href="namespacelibcommunism_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html">SetJmp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structlibcommunism_1_1internal_1_1SetJmp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcommunism::internal::SetJmp Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Context switching utilizing the C library <code>setjmp()</code> and <code>longjmp()</code> methods.  
 <a href="structlibcommunism_1_1internal_1_1SetJmp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext.html">EntryContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context structure passed to the entry point of a setjmp based cothread.  <a href="structlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad3454544e7b2ca889b8e3bfecd5b2ac1"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#ad3454544e7b2ca889b8e3bfecd5b2ac1">JmpBufFor</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *thread)</td></tr>
<tr class="separator:ad3454544e7b2ca889b8e3bfecd5b2ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614632827e750f8be47e56065417cc45"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a614632827e750f8be47e56065417cc45">AllocMainCothread</a> ()</td></tr>
<tr class="separator:a614632827e750f8be47e56065417cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15481c390c0864f13ccdc82f3e362385"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a15481c390c0864f13ccdc82f3e362385">Prepare</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *thread, const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Cothread::Entry</a> &amp;entry)</td></tr>
<tr class="separator:a15481c390c0864f13ccdc82f3e362385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f299fc7a2363930bdf08e9b1a32ac27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a4f299fc7a2363930bdf08e9b1a32ac27">InvokeCothreadDidReturnHandler</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *from)</td></tr>
<tr class="separator:a4f299fc7a2363930bdf08e9b1a32ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f788f1d2d0312fcb75f67d002ae238"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#af2f788f1d2d0312fcb75f67d002ae238">SignalHandlerSetupThunk</a> (int)</td></tr>
<tr class="separator:af2f788f1d2d0312fcb75f67d002ae238"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a49447cf4552f3f52f19f0f4c01dde38f"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a49447cf4552f3f52f19f0f4c01dde38f">kStackAlignment</a> {64}</td></tr>
<tr class="separator:a49447cf4552f3f52f19f0f4c01dde38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad47683f0733863a41dedd4e00671d1"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#afad47683f0733863a41dedd4e00671d1">kMainStackSize</a> {512}</td></tr>
<tr class="separator:afad47683f0733863a41dedd4e00671d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be761696b3a4c34e099ac4d4730b3ce"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a7be761696b3a4c34e099ac4d4730b3ce">kDefaultStackSize</a> {sizeof(uintptr_t) * 0x10000}</td></tr>
<tr class="separator:a7be761696b3a4c34e099ac4d4730b3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947eb06ca191e8d372438570b1d65034"><td class="memItemLeft" align="right" valign="top">static thread_local <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a947eb06ca191e8d372438570b1d65034">gCurrentHandle</a> {nullptr}</td></tr>
<tr class="separator:a947eb06ca191e8d372438570b1d65034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ff5502b0dbd561ec18a5458d82f5a"><td class="memItemLeft" align="right" valign="top">static thread_local std::array&lt; uintptr_t, <a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#afad47683f0733863a41dedd4e00671d1">kMainStackSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a219ff5502b0dbd561ec18a5458d82f5a">gMainStack</a></td></tr>
<tr class="separator:a219ff5502b0dbd561ec18a5458d82f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44267d6a6825b7362a9d3de0dbe12f51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext.html">EntryContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#a44267d6a6825b7362a9d3de0dbe12f51">gCurrentlyPreparing</a> {nullptr}</td></tr>
<tr class="separator:a44267d6a6825b7362a9d3de0dbe12f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb055b62dca595e8598b4b26a7d9fa49"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#aeb055b62dca595e8598b4b26a7d9fa49">gSignalLock</a></td></tr>
<tr class="separator:aeb055b62dca595e8598b4b26a7d9fa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Context switching utilizing the C library <code>setjmp()</code> and <code>longjmp()</code> methods. </p>
<p>The means by which this is works is based on ideas by Ralf S. Engelschall, from the 2000 paper titled <a href="http://www.xmailserver.org/rse-pmt.pdf">Portable Multithreading.</a> Thread stacks are set up in a portable way by making use of signal handlers, so this should be supported on basically all targets that have a functional C library and are UNIX-y.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Since signals are a per-process resource, allocation of cothreads effectively becomes serialized to ensure safety. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00024">24</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a614632827e750f8be47e56065417cc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614632827e750f8be47e56065417cc45">&#9670;&nbsp;</a></span>AllocMainCothread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetJmp::AllocMainCothread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the <a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> instance for the current kernel thread. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8cpp_source.html#l00116">116</a> of file <a class="el" href="SetJmp_8cpp_source.html">SetJmp.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                               {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keyword">auto</span> main = <span class="keyword">new</span> <a class="code" href="classlibcommunism_1_1Cothread.html">Cothread</a>(<a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a219ff5502b0dbd561ec18a5458d82f5a">gMainStack</a>, <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a219ff5502b0dbd561ec18a5458d82f5a">gMainStack</a>.data() + <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#afad47683f0733863a41dedd4e00671d1">SetJmp::kMainStackSize</a>);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a947eb06ca191e8d372438570b1d65034">gCurrentHandle</a> = main;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;}</div>
<div class="ttc" id="aclasslibcommunism_1_1Cothread_html"><div class="ttname"><a href="classlibcommunism_1_1Cothread.html">libcommunism::Cothread</a></div><div class="ttdoc">Instance of a single cooperative thread.</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8h_source.html#l00026">Cothread.h:26</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_a219ff5502b0dbd561ec18a5458d82f5a"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#a219ff5502b0dbd561ec18a5458d82f5a">libcommunism::internal::SetJmp::gMainStack</a></div><div class="ttdeci">static thread_local std::array&lt; uintptr_t, kMainStackSize &gt; gMainStack</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00102">SetJmp.h:102</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_a947eb06ca191e8d372438570b1d65034"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#a947eb06ca191e8d372438570b1d65034">libcommunism::internal::SetJmp::gCurrentHandle</a></div><div class="ttdeci">static thread_local Cothread * gCurrentHandle</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00089">SetJmp.h:89</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_afad47683f0733863a41dedd4e00671d1"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#afad47683f0733863a41dedd4e00671d1">libcommunism::internal::SetJmp::kMainStackSize</a></div><div class="ttdeci">static constexpr const size_t kMainStackSize</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00076">SetJmp.h:76</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f299fc7a2363930bdf08e9b1a32ac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f299fc7a2363930bdf08e9b1a32ac27">&#9670;&nbsp;</a></span>InvokeCothreadDidReturnHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetJmp::InvokeCothreadDidReturnHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke the return handler. This is put in a separate function so it shows up on the stack trace explicitly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td><a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> that returned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetJmp_8cpp_source.html#l00127">127</a> of file <a class="el" href="SetJmp_8cpp_source.html">SetJmp.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                                                          {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <a class="code" href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">gReturnHandler</a>(from);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;}</div>
<div class="ttc" id="anamespacelibcommunism_1_1internal_html_a7ffa60f4788d5229f04e2ad5a41b2935"><div class="ttname"><a href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">libcommunism::internal::gReturnHandler</a></div><div class="ttdeci">std::function&lt; void(libcommunism::Cothread *)&gt; gReturnHandler</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8cpp_source.html#l00067">Cothread.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3454544e7b2ca889b8e3bfecd5b2ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3454544e7b2ca889b8e3bfecd5b2ac1">&#9670;&nbsp;</a></span>JmpBufFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto libcommunism::internal::SetJmp::JmpBufFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the <code>sigjmp_buf</code> structure for a given cooperative thread.</p>
<p>It's stored at the top of its stack buffer. The actual stack available to the program will be reduced accordingly, but it is still possible for the program to overflow into this structure and wreak havoc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread whose setjmp buffer to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread's setjmp, in the stack allocation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00049">49</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                                            {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>sigjmp_buf *<span class="keyword">&gt;</span>(thread-&gt;stack.data());</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15481c390c0864f13ccdc82f3e362385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15481c390c0864f13ccdc82f3e362385">&#9670;&nbsp;</a></span>Prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetJmp::Prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Cothread::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepares the <code>sigjmp_buf</code> buffer for the cothread, so that when it is switched to, it will begin executing its entry point.</p>
<p>This abuses signal handling to set up the return stack in a platform independent way. The algorithm is very well described in Engelschall's Portable Multithreading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td><a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> to initialize </td></tr>
    <tr><td class="paramname">entry</td><td>Entry point to execute</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If context allocation or initialization failed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetJmp_8cpp_source.html#l00144">144</a> of file <a class="el" href="SetJmp_8cpp_source.html">SetJmp.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                                                                 {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordtype">int</span> err{0};</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keyword">struct </span>sigaction handler, oldHandler;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    stack_t stack{}, oldStack{};</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160; </div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">if</span>(!<a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a947eb06ca191e8d372438570b1d65034">gCurrentHandle</a>) <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a614632827e750f8be47e56065417cc45">SetJmp::AllocMainCothread</a>();</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160; </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keyword">auto</span> jbuf = <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#ad3454544e7b2ca889b8e3bfecd5b2ac1">JmpBufFor</a>(thread);</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    memset(jbuf, 0, <span class="keyword">sizeof</span>(*jbuf));</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160; </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="comment">// prepare the signal handling stack</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keyword">auto</span> offset = <span class="keyword">sizeof</span>(sigjmp_buf);</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">if</span>(offset % <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a49447cf4552f3f52f19f0f4c01dde38f">kStackAlignment</a>) {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        offset += <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a49447cf4552f3f52f19f0f4c01dde38f">kStackAlignment</a> - (offset % <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a49447cf4552f3f52f19f0f4c01dde38f">kStackAlignment</a>);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160; </div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    stack.ss_sp = <span class="keyword">reinterpret_cast&lt;</span>std::byte *<span class="keyword">&gt;</span>(thread-&gt;stack.data()) + offset;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    stack.ss_size = (thread-&gt;stack.size() * <span class="keyword">sizeof</span>(uintptr_t)) - offset;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160; </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keyword">auto</span> info = <span class="keyword">new</span> EntryContext(thread, entry);</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">if</span>(!info) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to allocate context&quot;</span>);</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160; </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="comment">// listen man you&#39;re just gonna have to trust me on this one</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keywordflow">try</span> {</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        std::lock_guard&lt;std::mutex&gt; lock(<a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#aeb055b62dca595e8598b4b26a7d9fa49">gSignalLock</a>);</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160; </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        err = sigaltstack(&amp;stack, &amp;oldStack);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">if</span>(err) {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">throw</span> std::system_error(errno, std::generic_category(), <span class="stringliteral">&quot;sigaltstack&quot;</span>);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        }</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160; </div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a44267d6a6825b7362a9d3de0dbe12f51">gCurrentlyPreparing</a> = info;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        std::atomic_thread_fence(std::memory_order_release);</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160; </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        handler.sa_handler = <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#af2f788f1d2d0312fcb75f67d002ae238">SignalHandlerSetupThunk</a>;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        handler.sa_flags = SA_ONSTACK;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        sigemptyset(&amp;handler.sa_mask);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160; </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        err = sigaction(SIGUSR1, &amp;handler, &amp;oldHandler);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <span class="keywordflow">if</span>(err) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keywordflow">throw</span> std::system_error(errno, std::generic_category(), <span class="stringliteral">&quot;sigaction&quot;</span>);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        }</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        err = <span class="keyword">raise</span>(SIGUSR1);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keywordflow">if</span>(err) {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keywordflow">throw</span> std::system_error(errno, std::generic_category(), <span class="stringliteral">&quot;raise&quot;</span>);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        sigaltstack(&amp;oldStack, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        sigaction(SIGUSR1, &amp;oldHandler, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    } <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception &amp;) {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keyword">delete</span> info;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    }</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_a44267d6a6825b7362a9d3de0dbe12f51"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#a44267d6a6825b7362a9d3de0dbe12f51">libcommunism::internal::SetJmp::gCurrentlyPreparing</a></div><div class="ttdeci">static EntryContext * gCurrentlyPreparing</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00110">SetJmp.h:110</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_a49447cf4552f3f52f19f0f4c01dde38f"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#a49447cf4552f3f52f19f0f4c01dde38f">libcommunism::internal::SetJmp::kStackAlignment</a></div><div class="ttdeci">static constexpr const size_t kStackAlignment</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00068">SetJmp.h:68</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_a614632827e750f8be47e56065417cc45"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#a614632827e750f8be47e56065417cc45">libcommunism::internal::SetJmp::AllocMainCothread</a></div><div class="ttdeci">static void AllocMainCothread()</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8cpp_source.html#l00116">SetJmp.cpp:116</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_ad3454544e7b2ca889b8e3bfecd5b2ac1"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#ad3454544e7b2ca889b8e3bfecd5b2ac1">libcommunism::internal::SetJmp::JmpBufFor</a></div><div class="ttdeci">static auto JmpBufFor(Cothread *thread)</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00049">SetJmp.h:49</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_aeb055b62dca595e8598b4b26a7d9fa49"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#aeb055b62dca595e8598b4b26a7d9fa49">libcommunism::internal::SetJmp::gSignalLock</a></div><div class="ttdeci">static std::mutex gSignalLock</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00121">SetJmp.h:121</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_af2f788f1d2d0312fcb75f67d002ae238"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#af2f788f1d2d0312fcb75f67d002ae238">libcommunism::internal::SetJmp::SignalHandlerSetupThunk</a></div><div class="ttdeci">static void SignalHandlerSetupThunk(int)</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8cpp_source.html#l00209">SetJmp.cpp:209</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af2f788f1d2d0312fcb75f67d002ae238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f788f1d2d0312fcb75f67d002ae238">&#9670;&nbsp;</a></span>SignalHandlerSetupThunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetJmp::SignalHandlerSetupThunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method that's registered as a signal handler when initializing a cothread.</p>
<p>Since we take this signal on the signal stack, it will set up the stack frame correctly, and we can correctly populate the setjmp buffer at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>Signal number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This relies on a global variable, so the prepare method must be sure that only a single thread is being prepared at a time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SetJmp_8cpp_source.html#l00209">209</a> of file <a class="el" href="SetJmp_8cpp_source.html">SetJmp.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                                               {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    (void) signal;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160; </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keyword">auto</span> ctx = <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a44267d6a6825b7362a9d3de0dbe12f51">gCurrentlyPreparing</a>;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">if</span>(sigsetjmp(*<a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#ad3454544e7b2ca889b8e3bfecd5b2ac1">JmpBufFor</a>(ctx-&gt;thread), 0)) {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        ctx-&gt;<a class="code" href="structlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext.html#a6767c57216b924cfe21a7122b9a695ee">entry</a>();</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <a class="code" href="structlibcommunism_1_1internal_1_1SetJmp.html#a4f299fc7a2363930bdf08e9b1a32ac27">InvokeCothreadDidReturnHandler</a>(ctx-&gt;thread);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    }</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext_html_a6767c57216b924cfe21a7122b9a695ee"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext.html#a6767c57216b924cfe21a7122b9a695ee">libcommunism::internal::SetJmp::EntryContext::entry</a></div><div class="ttdeci">Cothread::Entry entry</div><div class="ttdoc">Entry point of the cothread.</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8h_source.html#l00032">SetJmp.h:32</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1SetJmp_html_a4f299fc7a2363930bdf08e9b1a32ac27"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1SetJmp.html#a4f299fc7a2363930bdf08e9b1a32ac27">libcommunism::internal::SetJmp::InvokeCothreadDidReturnHandler</a></div><div class="ttdeci">static void InvokeCothreadDidReturnHandler(Cothread *from)</div><div class="ttdef"><b>Definition:</b> <a href="SetJmp_8cpp_source.html#l00127">SetJmp.cpp:127</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a947eb06ca191e8d372438570b1d65034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947eb06ca191e8d372438570b1d65034">&#9670;&nbsp;</a></span>gCurrentHandle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> * SetJmp::gCurrentHandle {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handle for the currently executing cothread in the calling physical thread. This is updated when switching cothreads, but will be <code>nullptr</code> until the first call to <code>SwitchTo()</code>. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00089">89</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<a id="a44267d6a6825b7362a9d3de0dbe12f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44267d6a6825b7362a9d3de0dbe12f51">&#9670;&nbsp;</a></span>gCurrentlyPreparing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibcommunism_1_1internal_1_1SetJmp_1_1EntryContext.html">SetJmp::EntryContext</a> * SetJmp::gCurrentlyPreparing {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global variable indicating the context of the current cothread whose state buffer is to be initialized. This is consulted in the signal handler to find the thread's actual entry point. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00110">110</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<a id="a219ff5502b0dbd561ec18a5458d82f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219ff5502b0dbd561ec18a5458d82f5a">&#9670;&nbsp;</a></span>gMainStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local std::array&lt; uintptr_t, <a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html#afad47683f0733863a41dedd4e00671d1">SetJmp::kMainStackSize</a> &gt; SetJmp::gMainStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pseudo-stack to use for the "main" cothread, i.e. the native kernel thread executing before a cothread is ever switched to it.</p>
<p>This buffer receives the stack frame of the context of the thread on the first invocation to SwitchTo(). When invoking the Current() method before executing a real cothread, the returned <a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> will correspond to this buffer.</p>
<p>It does not have to be particularly large, since the stack is actually allocated by the system already, and this "stack" only holds the <code>sigjmp_buf</code>. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00102">102</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<a id="aeb055b62dca595e8598b4b26a7d9fa49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb055b62dca595e8598b4b26a7d9fa49">&#9670;&nbsp;</a></span>gSignalLock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex SetJmp::gSignalLock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Because the signals are shared between all threads in a process, including the associated signal stacks, it's possible that multiple threads attempting to be prepared simultaneously would cause issues.</p>
<p>Therefore, this lock is taken for the duration of signal based operations (that is, the entire time between saving the current signal handler, installing our custom ones, raising the signal, and then restoring the old h andlers) needed to initialize the context buffer. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00121">121</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<a id="a7be761696b3a4c34e099ac4d4730b3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be761696b3a4c34e099ac4d4730b3ce">&#9670;&nbsp;</a></span>kDefaultStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::SetJmp::kDefaultStackSize {sizeof(uintptr_t) * 0x10000}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default stack size in bytes, if none was requested by the caller. Since this implementation may work on different width architectures, we define this as 64K worth of machine words. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00082">82</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<a id="afad47683f0733863a41dedd4e00671d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad47683f0733863a41dedd4e00671d1">&#9670;&nbsp;</a></span>kMainStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::SetJmp::kMainStackSize {512}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size of the stack buffer for the "fake" initial cothread, in machine words. This only needs to be large enough to fit the register stack frame. This <em>must</em> be a power of two.</p>
<p>It must be sufficiently large to fit an sigjmp_buf it. </p>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00076">76</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<a id="a49447cf4552f3f52f19f0f4c01dde38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49447cf4552f3f52f19f0f4c01dde38f">&#9670;&nbsp;</a></span>kStackAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::SetJmp::kStackAlignment {64}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requested alignment for stack allocations.</p>
<p>64 bytes is the most stringent alignment requirements we should probably encounter in the real world (one cache line on most systems) and alignment doesn't result in <em>that</em> much overhead so this is fine.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This must be a power of 2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SetJmp_8h_source.html#l00068">68</a> of file <a class="el" href="SetJmp_8h_source.html">SetJmp.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/arch/setjmp/<a class="el" href="SetJmp_8h_source.html">SetJmp.h</a></li>
<li>src/arch/setjmp/<a class="el" href="SetJmp_8cpp_source.html">SetJmp.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
