<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcommunism: libcommunism::Cothread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcommunism
   </div>
   <div id="projectbrief">Userspace cooperative threading library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcommunism.html">libcommunism</a></li><li class="navelem"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibcommunism_1_1Cothread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcommunism::Cothread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instance of a single cooperative thread.  
 <a href="classlibcommunism_1_1Cothread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cothread_8h_source.html">Cothread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a56facf24195f6223f0fc1397a9a71467"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Entry</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:a56facf24195f6223f0fc1397a9a71467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for an entry point of a cothread.  <a href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">More...</a><br /></td></tr>
<tr class="separator:a56facf24195f6223f0fc1397a9a71467"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36ebd9f605c88b0155d4b02b7859b05b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a36ebd9f605c88b0155d4b02b7859b05b">Cothread</a> (const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Entry</a> &amp;entry, const size_t stackSize=0)</td></tr>
<tr class="separator:a36ebd9f605c88b0155d4b02b7859b05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed66b16fd29c944ebbade6f07efb1c78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#aed66b16fd29c944ebbade6f07efb1c78">Cothread</a> (const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Entry</a> &amp;entry, std::span&lt; uintptr_t &gt; stack)</td></tr>
<tr class="separator:aed66b16fd29c944ebbade6f07efb1c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdb57c1f9305b5e9f604bb0817a63fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a0cdb57c1f9305b5e9f604bb0817a63fa">~Cothread</a> ()</td></tr>
<tr class="separator:a0cdb57c1f9305b5e9f604bb0817a63fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672bcee91d509ed6a145c713066e8527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a672bcee91d509ed6a145c713066e8527">switchTo</a> ()</td></tr>
<tr class="separator:a672bcee91d509ed6a145c713066e8527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed231da1a3ad90e982650a08dc645c"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#abeed231da1a3ad90e982650a08dc645c">getLabel</a> () const</td></tr>
<tr class="separator:abeed231da1a3ad90e982650a08dc645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9fabe12335420c2fcd05fe748cba18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#adc9fabe12335420c2fcd05fe748cba18">setLabel</a> (const std::string &amp;newLabel)</td></tr>
<tr class="separator:adc9fabe12335420c2fcd05fe748cba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2637b683ea95c78887a13347aeccfd8a"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a2637b683ea95c78887a13347aeccfd8a">getStackSize</a> () const</td></tr>
<tr class="separator:a2637b683ea95c78887a13347aeccfd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3248210c4400f2e77c35a7364bc57e73"><td class="memItemLeft" align="right" valign="top">constexpr void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a3248210c4400f2e77c35a7364bc57e73">getStack</a> () const</td></tr>
<tr class="separator:a3248210c4400f2e77c35a7364bc57e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a81810be5c4a49a7f6c36f3e8dd8c36bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a81810be5c4a49a7f6c36f3e8dd8c36bb">Current</a> ()</td></tr>
<tr class="separator:a81810be5c4a49a7f6c36f3e8dd8c36bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6febcd8872e14341c66b9c5a447c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a1aa6febcd8872e14341c66b9c5a447c6">SetReturnHandler</a> (const std::function&lt; void(<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *)&gt; &amp;handler)</td></tr>
<tr class="separator:a1aa6febcd8872e14341c66b9c5a447c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaef12afd0dd667c02876716e5833865"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#aeaef12afd0dd667c02876716e5833865">ResetReturnHandler</a> ()</td></tr>
<tr class="separator:aeaef12afd0dd667c02876716e5833865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a79870e7f40c6ef21612f6464e875e02b"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a79870e7f40c6ef21612f6464e875e02b">internal::Amd64</a></td></tr>
<tr class="separator:a79870e7f40c6ef21612f6464e875e02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128ff87a6f8516e7a323518fa902be6d"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a128ff87a6f8516e7a323518fa902be6d">internal::Aarch64</a></td></tr>
<tr class="separator:a128ff87a6f8516e7a323518fa902be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ef8e61c4426dd2cca2d5a4581cd3b3"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a61ef8e61c4426dd2cca2d5a4581cd3b3">internal::SetJmp</a></td></tr>
<tr class="separator:a61ef8e61c4426dd2cca2d5a4581cd3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afdd85978899aa0ac87b95e44562919"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a8afdd85978899aa0ac87b95e44562919">internal::UContext</a></td></tr>
<tr class="separator:a8afdd85978899aa0ac87b95e44562919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7ea46400672eaacc1ae6ddf027a245"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#aba7ea46400672eaacc1ae6ddf027a245">internal::x86</a></td></tr>
<tr class="separator:aba7ea46400672eaacc1ae6ddf027a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instance of a single cooperative thread. </p>
<p>Cooperative threads are threads that perform context switching in userspace, rather than relying on the kernel to do this. This has distinct performance advantages as the context switch is avoided, which costs a significant amount of clock cycles. </p>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00028">28</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a56facf24195f6223f0fc1397a9a71467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56facf24195f6223f0fc1397a9a71467">&#9670;&nbsp;</a></span>Entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">libcommunism::Cothread::Entry</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for an entry point of a cothread. </p>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00054">54</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36ebd9f605c88b0155d4b02b7859b05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ebd9f605c88b0155d4b02b7859b05b">&#9670;&nbsp;</a></span>Cothread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cothread::Cothread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>stackSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new cothread without explicitly allocating its stack.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The backing storage for the cothread is allocated internally by the platform implementation and not directly accessible to clients of this interface. Depending on the platform, it may be allocated in a special way to match how normal stacks are allocated on the platform, rather than by using a mechanism like <code>malloc()</code>. That is to say, you should not have any expectations on how or where the stack is allocated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the entry point returns, the the cothread return handler is invoked; its default action is to terminate the program, as the state of the stack after return from the main thread is undefined and may result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Method to execute on entry to this cothread </td></tr>
    <tr><td class="paramname">stackSize</td><td>Size of the stack to be allocated, in bytes. it should be a multiple of the machine word size, or specify zero to use the platform default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the memory for the cothread could not be allocated. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If the provided stack size is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized cothread object</dd></dl>
<p>Allocates a cothread including a context region of the specified size.</p>
<p>Allocates a cothread including a context region of the specified size.</p>
<p>This ensures there's sufficient bonus space allocated to hold the sigjmp_buf.</p>
<p>Allocates a cothread including a context region of the specified size.</p>
<p>This ensures there's sufficient bonus space allocated to hold the ucontext. </p>

<p class="definition">Definition at line <a class="el" href="aarch64_2Common_8cpp_source.html#l00029">29</a> of file <a class="el" href="aarch64_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                                             {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="keywordtype">void</span> *buf{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="comment">// round down stack size to ensure it&#39;s aligned before allocating it</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keyword">auto</span> allocSize = stackSize &amp; ~(Aarch64::kStackAlignment - 1);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    allocSize = allocSize ? allocSize : Aarch64::kDefaultStackSize;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    allocSize += Aarch64::kContextSaveAreaSize;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    buf = Aarch64::AllocStack(allocSize);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="comment">// create it as if we had provided the memory in the first place</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    this-&gt;stack = {<span class="keyword">reinterpret_cast&lt;</span>uintptr_t *<span class="keyword">&gt;</span>(buf), allocSize / <span class="keyword">sizeof</span>(uintptr_t)};</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    this-&gt;flags = Cothread::Flags::OwnsStack;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160; </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    Aarch64::Prepare(<span class="keyword">this</span>, entry);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed66b16fd29c944ebbade6f07efb1c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed66b16fd29c944ebbade6f07efb1c78">&#9670;&nbsp;</a></span>Cothread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cothread::Cothread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; uintptr_t &gt;&#160;</td>
          <td class="paramname"><em>_stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new cothread, using an existing buffer to store its stack.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You are responsible for managing the buffer memory, i.e. freeing it after the cothread has been deallocated. See notes for important information.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the entry point returns, the the cothread return handler is invoked; its default action is to terminate the program, as the state of the stack after return from the main thread is undefined and may result in undefined behavior.</dd>
<dd>
The provided buffer must remain valid for the duration of the cothread's life. If it is deallocated or otherwise reused during the lifetime of the cothread, undefined behavior results. You must not attempt to manually modify the contents of the buffer. Additionally, it must meet alignment requirements for stacks on the underlying platform. (A 64 byte alignment should be safe for most platforms.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Method to execute on entry to this cothread </td></tr>
    <tr><td class="paramname">stack</td><td>Buffer to use as the stack of the cothread</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the provided stack is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized cothread object</dd></dl>
<p>Allocates a cothread with an existing region of memory to back its stack.</p>
<p>Allocates a cothread with an existing region of memory to back its stack and jump buffer. </p>

<p class="definition">Definition at line <a class="el" href="aarch64_2Common_8cpp_source.html#l00046">46</a> of file <a class="el" href="aarch64_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                                                                : stack(_stack) {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    Aarch64::ValidateStackSize(_stack.size() * <span class="keyword">sizeof</span>(uintptr_t));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    Aarch64::Prepare(<span class="keyword">this</span>, entry);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cdb57c1f9305b5e9f604bb0817a63fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdb57c1f9305b5e9f604bb0817a63fa">&#9670;&nbsp;</a></span>~Cothread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cothread::~Cothread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a previously allocated cothread, and deallocates any underlying buffer memory used by it.</p>
<dl class="section note"><dt>Note</dt><dd>Destroying the currently executing cothread results in undefined behavior, as it will cause its stack to be deallocated.</dd></dl>
<p>Deallocates a cothread. This releases the underlying stack if we allocated it. </p>

<p class="definition">Definition at line <a class="el" href="aarch64_2Common_8cpp_source.html#l00051">51</a> of file <a class="el" href="aarch64_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">static_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(this-&gt;flags) &amp; <span class="keyword">static_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(Flags::OwnsStack)) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        Aarch64::DeallocStack(this-&gt;stack.data());</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a81810be5c4a49a7f6c36f3e8dd8c36bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81810be5c4a49a7f6c36f3e8dd8c36bb">&#9670;&nbsp;</a></span>Current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> * Cothread::Current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the cothread currently executing on the calling "physical" thread.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the calling thread is not executing a cothread, a special handle is returned that points to a static, per thread buffer. Its sole purpose is to store the register state of the caller that invoked the first cothread on this physical thread. Currently, that buffer is not directly accessible, aside from storing this handle before any cothreads are executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the current cothread</dd></dl>
<p>Returns the handle to the currently executing cothread.</p>
<p>If no cothread has been lanched yet, the "fake" initial cothread handle is returned. </p>

<p class="definition">Definition at line <a class="el" href="aarch64_2Common_8cpp_source.html#l00024">24</a> of file <a class="el" href="aarch64_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                            {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="keywordflow">if</span>(!Aarch64::gCurrentHandle) Aarch64::AllocMainCothread();</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> Aarch64::gCurrentHandle;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abeed231da1a3ad90e982650a08dc645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeed231da1a3ad90e982650a08dc645c">&#9670;&nbsp;</a></span>getLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto&amp; libcommunism::Cothread::getLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the debug label (name) associated with this cothread.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the thread's debug label </dd></dl>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00166">166</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                                         {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordflow">return</span> this-&gt;label;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3248210c4400f2e77c35a7364bc57e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3248210c4400f2e77c35a7364bc57e73">&#9670;&nbsp;</a></span>getStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void* libcommunism::Cothread::getStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the location of the top of the cothread's stack.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Regardless of the direction of the platform's stack growth, the top here refers to the lowest address of the stack. That is, the range of memory reserved for stack is <code>[start, start + <a class="el" href="classlibcommunism_1_1Cothread.html#a2637b683ea95c78887a13347aeccfd8a">getStackSize()</a>)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You should never attempt to modify the stack, particularly while the cothread is executing. Its contents are highly machine and platform dependent.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the top of the stack </dd></dl>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00201">201</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                         {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            <span class="keywordflow">return</span> this-&gt;stack.data();</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2637b683ea95c78887a13347aeccfd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2637b683ea95c78887a13347aeccfd8a">&#9670;&nbsp;</a></span>getStackSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t libcommunism::Cothread::getStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the size of the cothread's stack. This should be intended mainly as an advisory value rather than as a way to check against stack overflow.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the stack, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00185">185</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                              {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            <span class="keywordflow">return</span> this-&gt;stack.size() * <span class="keyword">sizeof</span>(uintptr_t);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeaef12afd0dd667c02876716e5833865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaef12afd0dd667c02876716e5833865">&#9670;&nbsp;</a></span>ResetReturnHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cothread::ResetReturnHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Installs the default handler for a cothread that returns from its entry point. This will terminate the program.</p>
<p>Installs the default cothread return handler. </p>

<p class="definition">Definition at line <a class="el" href="Cothread_8cpp_source.html#l00081">81</a> of file <a class="el" href="Cothread_8cpp_source.html">Cothread.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                                  {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <a class="code" href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">gReturnHandler</a> = DefaultCothreadReturnedHandler;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;}</div>
<div class="ttc" id="anamespacelibcommunism_1_1internal_html_a7ffa60f4788d5229f04e2ad5a41b2935"><div class="ttname"><a href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">libcommunism::internal::gReturnHandler</a></div><div class="ttdeci">std::function&lt; void(libcommunism::Cothread *)&gt; gReturnHandler</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8cpp_source.html#l00067">Cothread.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adc9fabe12335420c2fcd05fe748cba18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9fabe12335420c2fcd05fe748cba18">&#9670;&nbsp;</a></span>setLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libcommunism::Cothread::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newLabel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the debug label (name) associated with this cothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newLabel</td><td>New string value to set as the cothread's label </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00175">175</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                                                 {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            this-&gt;label = newLabel;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1aa6febcd8872e14341c66b9c5a447c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa6febcd8872e14341c66b9c5a447c6">&#9670;&nbsp;</a></span>SetReturnHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cothread::SetReturnHandler </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the method that's invoked when a cothread returns from its entry point. The deafult action is to terminate the program when this occurs.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's suggested that cothreads returning from entry is treated as a fatal programming error. The state of the cothread's stack is not well defined after it returns (w.r.t. alignment;) instead design your code so that it switches to another cothread when it's done, at which point it can be deallocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Function to invoke with a pointer to the cothread that returned from its main method.</td></tr>
  </table>
  </dd>
</dl>
<p>Updates the default cothread return handler. </p>

<p class="definition">Definition at line <a class="el" href="Cothread_8cpp_source.html#l00074">74</a> of file <a class="el" href="Cothread_8cpp_source.html">Cothread.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                                                                             {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">gReturnHandler</a> = handler;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a672bcee91d509ed6a145c713066e8527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672bcee91d509ed6a145c713066e8527">&#9670;&nbsp;</a></span>switchTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cothread::switchTo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a context switch to this cothread.</p>
<p>This method saves the context of the current cothread (registers, including the stack pointer) on top of its stack; then restores registers, stack and returns control to the destination cothread.</p>
<dl class="section note"><dt>Note</dt><dd>Do not attempt to switch to a currently executing cothread, whether it is on the same physical thread or not. This will corrupt both cothreads' stacks and result in undefined behavior.</dd></dl>
<p>Performs a context switch to the provided cothread.</p>
<p>The state of the caller is stored on the stack of the currently active thread.</p>
<p>Performs a context switch to the provided cothread. </p>

<p class="definition">Definition at line <a class="el" href="aarch64_2Common_8cpp_source.html#l00057">57</a> of file <a class="el" href="aarch64_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                        {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keyword">auto</span> from = Aarch64::gCurrentHandle;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    Aarch64::gCurrentHandle = <span class="keyword">this</span>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    Aarch64::Switch(from, <span class="keyword">this</span>);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a128ff87a6f8516e7a323518fa902be6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128ff87a6f8516e7a323518fa902be6d">&#9670;&nbsp;</a></span>internal::Aarch64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structlibcommunism_1_1internal_1_1Aarch64.html">internal::Aarch64</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00030">30</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<a id="a79870e7f40c6ef21612f6464e875e02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79870e7f40c6ef21612f6464e875e02b">&#9670;&nbsp;</a></span>internal::Amd64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structlibcommunism_1_1internal_1_1Amd64.html">internal::Amd64</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00029">29</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<a id="a61ef8e61c4426dd2cca2d5a4581cd3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ef8e61c4426dd2cca2d5a4581cd3b3">&#9670;&nbsp;</a></span>internal::SetJmp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structlibcommunism_1_1internal_1_1SetJmp.html">internal::SetJmp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00031">31</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<a id="a8afdd85978899aa0ac87b95e44562919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afdd85978899aa0ac87b95e44562919">&#9670;&nbsp;</a></span>internal::UContext</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structlibcommunism_1_1internal_1_1UContext.html">internal::UContext</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00032">32</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<a id="aba7ea46400672eaacc1ae6ddf027a245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7ea46400672eaacc1ae6ddf027a245">&#9670;&nbsp;</a></span>internal::x86</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structlibcommunism_1_1internal_1_1x86.html">internal::x86</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00033">33</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/libcommunism/<a class="el" href="Cothread_8h_source.html">Cothread.h</a></li>
<li>src/arch/aarch64/<a class="el" href="aarch64_2Common_8cpp_source.html">Common.cpp</a></li>
<li>src/arch/setjmp/<a class="el" href="SetJmp_8cpp_source.html">SetJmp.cpp</a></li>
<li>src/arch/ucontext/<a class="el" href="UContext_8cpp_source.html">UContext.cpp</a></li>
<li>src/<a class="el" href="Cothread_8cpp_source.html">Cothread.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
