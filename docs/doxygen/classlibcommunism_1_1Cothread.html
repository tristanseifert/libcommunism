<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcommunism: libcommunism::Cothread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcommunism
   </div>
   <div id="projectbrief">Userspace cooperative threading library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcommunism.html">libcommunism</a></li><li class="navelem"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibcommunism_1_1Cothread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcommunism::Cothread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instance of a single cooperative thread.  
 <a href="classlibcommunism_1_1Cothread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cothread_8h_source.html">Cothread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0723f9c0eb535813233532ae15d4b64c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a0723f9c0eb535813233532ae15d4b64c">Cothread</a> (void(*entry)(void *), void *ctx=nullptr, const size_t stackSize=0)</td></tr>
<tr class="separator:a0723f9c0eb535813233532ae15d4b64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d432c585f43844feb86cb23d38d591"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a20d432c585f43844feb86cb23d38d591">Cothread</a> (std::span&lt; uintptr_t &gt; stack, void(*entry)(void *), void *ctx=nullptr)</td></tr>
<tr class="separator:a20d432c585f43844feb86cb23d38d591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdb57c1f9305b5e9f604bb0817a63fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a0cdb57c1f9305b5e9f604bb0817a63fa">~Cothread</a> ()</td></tr>
<tr class="separator:a0cdb57c1f9305b5e9f604bb0817a63fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672bcee91d509ed6a145c713066e8527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a672bcee91d509ed6a145c713066e8527">switchTo</a> ()</td></tr>
<tr class="separator:a672bcee91d509ed6a145c713066e8527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed231da1a3ad90e982650a08dc645c"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#abeed231da1a3ad90e982650a08dc645c">getLabel</a> () const</td></tr>
<tr class="separator:abeed231da1a3ad90e982650a08dc645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9fabe12335420c2fcd05fe748cba18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#adc9fabe12335420c2fcd05fe748cba18">setLabel</a> (const std::string &amp;newLabel)</td></tr>
<tr class="separator:adc9fabe12335420c2fcd05fe748cba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a81810be5c4a49a7f6c36f3e8dd8c36bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a81810be5c4a49a7f6c36f3e8dd8c36bb">Current</a> ()</td></tr>
<tr class="separator:a81810be5c4a49a7f6c36f3e8dd8c36bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6febcd8872e14341c66b9c5a447c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a1aa6febcd8872e14341c66b9c5a447c6">SetReturnHandler</a> (const std::function&lt; void(<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *)&gt; &amp;handler)</td></tr>
<tr class="separator:a1aa6febcd8872e14341c66b9c5a447c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a79870e7f40c6ef21612f6464e875e02b"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcommunism_1_1Cothread.html#a79870e7f40c6ef21612f6464e875e02b">internal::Amd64</a></td></tr>
<tr class="separator:a79870e7f40c6ef21612f6464e875e02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instance of a single cooperative thread. </p>
<p>Cooperative threads are threads that perform context switching in userspace, rather than relying on the kernel to do this. This has distinct performance advantages as the context switch is avoided, which costs a significant amount of clock cycles. </p>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00024">24</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0723f9c0eb535813233532ae15d4b64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0723f9c0eb535813233532ae15d4b64c">&#9670;&nbsp;</a></span>Cothread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cothread::Cothread </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>contextSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new cothread without explicitly allocating its state buffer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The backing storage for the cothread is allocated internally by the platform implementation and not directly accessible to clients of this interface. Depending on the platform, it may be allocated in a special way to match how normal stacks are allocated on the platform, rather than by using a mechanism like <code>malloc()</code>. That is to say, you should not have any expectations on how or where the stack is allocated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the entry point returns, the the cothread return handler is invoked; its default action is to terminate the program, as the state of the stack after return from the main thread is undefined and may result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Method to execute on entry to this cothread </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context parameter passed to the cothread entry </td></tr>
    <tr><td class="paramname">stackSize</td><td>Size of the stack to be allocated, in bytes. it should be a multiple of the machine word size, or specify zero to use the platform default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the memory for the cothread could not be allocated. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If the provided stack size is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized cothread object</dd></dl>
<p>Allocates a cothread including a context region of the specified size. </p>

<p class="definition">Definition at line <a class="el" href="Amd64_8cpp_source.html#l00040">40</a> of file <a class="el" href="Amd64_8cpp_source.html">Amd64.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                                                                             {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordtype">void</span> *buf{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordtype">int</span> err{-1};</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">// round down context size to ensure it&#39;s aligned</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keyword">auto</span> allocSize = contextSize &amp; ~(Amd64::kStackAlignment - 1);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    allocSize = allocSize ? allocSize : Amd64::kDefaultStackSize;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="comment">// allocate buffer</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    err = posix_memalign(&amp;buf, Amd64::kStackAlignment, allocSize);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">if</span>(err) {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;posix_memalign() failed&quot;</span>);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="comment">// create it as if we had provided the memory in the first place</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    this-&gt;stack = {<span class="keyword">reinterpret_cast&lt;</span>uintptr_t *<span class="keyword">&gt;</span>(buf), allocSize / <span class="keyword">sizeof</span>(uintptr_t)};</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    this-&gt;flags = Cothread::Flags::OwnsStack;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    Amd64::Prepare(<span class="keyword">this</span>, entry, ctx);</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a20d432c585f43844feb86cb23d38d591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d432c585f43844feb86cb23d38d591">&#9670;&nbsp;</a></span>Cothread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cothread::Cothread </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; uintptr_t &gt;&#160;</td>
          <td class="paramname"><em>_stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new cothread, using an existing buffer to store its context.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You are responsible for managing the buffer memory, i.e. freeing it after the cothread has been deallocated. See notes for important information.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the entry point returns, the the cothread return handler is invoked; its default action is to terminate the program, as the state of the stack after return from the main thread is undefined and may result in undefined behavior.</dd>
<dd>
The provided buffer must remain valid for the duration of the cothread's life. If it is deallocated or otherwise reused during the lifetime of the cothread, undefined behavior results. You must not attempt to manually modify the contents of the buffer. Additionally, it must meet alignment requirements for stacks on the underlying platform. (A 64 byte alignment should be safe for most platforms.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Buffer to use as the stack of the cothread </td></tr>
    <tr><td class="paramname">entry</td><td>Method to execute on entry to this cothread </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context passed to the cothread entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the provided stack is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized cothread object</dd></dl>
<p>Allocates a cothread with an existing region of memory to back its stack. </p>

<p class="definition">Definition at line <a class="el" href="Amd64_8cpp_source.html#l00064">64</a> of file <a class="el" href="Amd64_8cpp_source.html">Amd64.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                                                                              : stack(_stack) {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    Amd64::ValidateStackSize(_stack.size() * <span class="keyword">sizeof</span>(uintptr_t));</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    Amd64::Prepare(<span class="keyword">this</span>, entry, ctx);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cdb57c1f9305b5e9f604bb0817a63fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdb57c1f9305b5e9f604bb0817a63fa">&#9670;&nbsp;</a></span>~Cothread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cothread::~Cothread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a previously allocated cothread, and deallocates any underlying buffer memory used by it.</p>
<dl class="section note"><dt>Note</dt><dd>Destroying the currently executing cothread results in undefined behavior, as it will cause its stack to be deallocated.</dd></dl>
<p>Deallocates a cothread. This releases the underlying stack if we allocated it. </p>

<p class="definition">Definition at line <a class="el" href="Amd64_8cpp_source.html#l00072">72</a> of file <a class="el" href="Amd64_8cpp_source.html">Amd64.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                    {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">static_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(this-&gt;flags) &amp; <span class="keyword">static_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(Flags::OwnsStack)) {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        free(this-&gt;stack.data());</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a81810be5c4a49a7f6c36f3e8dd8c36bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81810be5c4a49a7f6c36f3e8dd8c36bb">&#9670;&nbsp;</a></span>Current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> * Cothread::Current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the cothread currently executing on the calling "physical" thread.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the calling thread is not executing a cothread, a special handle is returned that points to a static, per thread buffer. Its sole purpose is to store the register state of the caller that invoked the first cothread on this physical thread. Currently, that buffer is not directly accessible, aside from storing this handle before any cothreads are executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the current cothread</dd></dl>
<p>Returns the handle to the currently executing cothread.</p>
<p>If no cothread has been lanched yet, the "fake" initial cothread handle is returned. </p>

<p class="definition">Definition at line <a class="el" href="Amd64_8cpp_source.html#l00032">32</a> of file <a class="el" href="Amd64_8cpp_source.html">Amd64.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                            {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">if</span>(!Amd64::gCurrentHandle) Amd64::AllocMainCothread();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">return</span> Amd64::gCurrentHandle;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abeed231da1a3ad90e982650a08dc645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeed231da1a3ad90e982650a08dc645c">&#9670;&nbsp;</a></span>getLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto&amp; libcommunism::Cothread::getLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the debug label (name) associated with this cothread.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the thread's debug label </dd></dl>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00141">141</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                                         {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <span class="keywordflow">return</span> this-&gt;label;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adc9fabe12335420c2fcd05fe748cba18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9fabe12335420c2fcd05fe748cba18">&#9670;&nbsp;</a></span>setLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libcommunism::Cothread::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newLabel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the debug label (name) associated with this cothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newLabel</td><td>New string value to set as the cothread's label </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00150">150</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                                                 {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            this-&gt;label = newLabel;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1aa6febcd8872e14341c66b9c5a447c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa6febcd8872e14341c66b9c5a447c6">&#9670;&nbsp;</a></span>SetReturnHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cothread::SetReturnHandler </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the method that's invoked when a cothread returns from its entry point. The deafult action is to terminate the program when this occurs.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's suggested that cothreads returning from entry is treated as a fatal programming error. The state of the cothread's stack is not well defined after it returns (w.r.t. alignment;) instead design your code so that it switches to another cothread when it's done, at which point it can be deallocated.</dd></dl>
<p>Updates the default cothread return handler. </p>

<p class="definition">Definition at line <a class="el" href="Cothread_8cpp_source.html#l00074">74</a> of file <a class="el" href="Cothread_8cpp_source.html">Cothread.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                                                                             {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">gReturnHandler</a> = handler;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
<div class="ttc" id="anamespacelibcommunism_1_1internal_html_a7ffa60f4788d5229f04e2ad5a41b2935"><div class="ttname"><a href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">libcommunism::internal::gReturnHandler</a></div><div class="ttdeci">std::function&lt; void(libcommunism::Cothread *)&gt; gReturnHandler</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8cpp_source.html#l00067">Cothread.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a672bcee91d509ed6a145c713066e8527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672bcee91d509ed6a145c713066e8527">&#9670;&nbsp;</a></span>switchTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cothread::switchTo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a context switch to this cothread.</p>
<p>This method saves the context of the current cothread (registers, including the stack pointer) in its context buffer; then restores registers, stack and returns control to the destination cothread.</p>
<dl class="section note"><dt>Note</dt><dd>Do not attempt to switch to a currently executing cothread, whether it is on the same physical thread or not. This will corrupt both cothreads' stacks and result in undefined behavior.</dd></dl>
<p>Performs a context switch to the provided cothread.</p>
<p>The state of the caller is stored into the context structure of the currently active thread. </p>

<p class="definition">Definition at line <a class="el" href="Amd64_8cpp_source.html#l00083">83</a> of file <a class="el" href="Amd64_8cpp_source.html">Amd64.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                        {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keyword">auto</span> from = Amd64::gCurrentHandle;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    Amd64::gCurrentHandle = <span class="keyword">this</span>;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    Amd64::Switch(from, <span class="keyword">this</span>);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a79870e7f40c6ef21612f6464e875e02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79870e7f40c6ef21612f6464e875e02b">&#9670;&nbsp;</a></span>internal::Amd64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structlibcommunism_1_1internal_1_1Amd64.html">internal::Amd64</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cothread_8h_source.html#l00025">25</a> of file <a class="el" href="Cothread_8h_source.html">Cothread.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/libcommunism/<a class="el" href="Cothread_8h_source.html">Cothread.h</a></li>
<li>src/arch/<a class="el" href="Amd64_8cpp_source.html">Amd64.cpp</a></li>
<li>src/<a class="el" href="Cothread_8cpp_source.html">Cothread.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
