<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcommunism: libcommunism::internal::UContext Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcommunism
   </div>
   <div id="projectbrief">Userspace cooperative threading library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcommunism.html">libcommunism</a></li><li class="navelem"><a class="el" href="namespacelibcommunism_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html">UContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structlibcommunism_1_1internal_1_1UContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcommunism::internal::UContext Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of context switching that uses the C library's <code>setcontext()</code> methods.  
 <a href="structlibcommunism_1_1internal_1_1UContext.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="UContext_8h_source.html">UContext.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structlibcommunism_1_1internal_1_1UContext_1_1Context.html" title="Context structure passed to the entry point of an ucontext.">Context</a> structure passed to the entry point of an ucontext.  <a href="structlibcommunism_1_1internal_1_1UContext_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a474cfba25de2bbbcecdb6dd3969ba314"><td class="memItemLeft" align="right" valign="top">static ucontext_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a474cfba25de2bbbcecdb6dd3969ba314">ContextFor</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *thread)</td></tr>
<tr class="separator:a474cfba25de2bbbcecdb6dd3969ba314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ea909ba16d45b9f6ccfbb5ba29b67c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a67ea909ba16d45b9f6ccfbb5ba29b67c">AllocMainCothread</a> ()</td></tr>
<tr class="separator:a67ea909ba16d45b9f6ccfbb5ba29b67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d8f0a78ac0c4e87d4eff55cd4bbfeb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#ae1d8f0a78ac0c4e87d4eff55cd4bbfeb">Prepare</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *thread, const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Cothread::Entry</a> &amp;entry)</td></tr>
<tr class="separator:ae1d8f0a78ac0c4e87d4eff55cd4bbfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4735f417c02d9d8308180b9398425a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a4b4735f417c02d9d8308180b9398425a">EntryStub</a> (int id)</td></tr>
<tr class="separator:a4b4735f417c02d9d8308180b9398425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e82993f5a89feb310864033f1eef279"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a5e82993f5a89feb310864033f1eef279">InvokeCothreadDidReturnHandler</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *from)</td></tr>
<tr class="separator:a5e82993f5a89feb310864033f1eef279"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5b5fb08c7e8b373ea1504ff4af4a1c53"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a5b5fb08c7e8b373ea1504ff4af4a1c53">kStackAlignment</a> {64}</td></tr>
<tr class="separator:a5b5fb08c7e8b373ea1504ff4af4a1c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb29eed86604c5fcbbf229af2d54c9"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#affcb29eed86604c5fcbbf229af2d54c9">kMainStackSize</a> {128}</td></tr>
<tr class="separator:affcb29eed86604c5fcbbf229af2d54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3bd6961f54c575400fdad9fd858f16"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#afe3bd6961f54c575400fdad9fd858f16">kDefaultStackSize</a> {sizeof(uintptr_t) * 0x10000}</td></tr>
<tr class="separator:afe3bd6961f54c575400fdad9fd858f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8323911e50712a84f288c4e54cf97cd"><td class="memItemLeft" align="right" valign="top">static thread_local <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#af8323911e50712a84f288c4e54cf97cd">gCurrentHandle</a> {nullptr}</td></tr>
<tr class="separator:af8323911e50712a84f288c4e54cf97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3781a09d44c312e93837b70127c9033"><td class="memItemLeft" align="right" valign="top">static thread_local std::array&lt; uintptr_t, <a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#affcb29eed86604c5fcbbf229af2d54c9">kMainStackSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#ad3781a09d44c312e93837b70127c9033">gMainStack</a></td></tr>
<tr class="separator:ad3781a09d44c312e93837b70127c9033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0459cebaff39cc99caf4a0d5ae3ec5ac"><td class="memItemLeft" align="right" valign="top">static std::unordered_map&lt; int, std::unique_ptr&lt; <a class="el" href="structlibcommunism_1_1internal_1_1UContext_1_1Context.html">Context</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a0459cebaff39cc99caf4a0d5ae3ec5ac">gContextInfo</a></td></tr>
<tr class="separator:a0459cebaff39cc99caf4a0d5ae3ec5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793d056aa4fd1d41300703b6fc65e708"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#a793d056aa4fd1d41300703b6fc65e708">gContextInfoLock</a></td></tr>
<tr class="separator:a793d056aa4fd1d41300703b6fc65e708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33edc632aa9ec3d78f4a3bd821d342a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#ad33edc632aa9ec3d78f4a3bd821d342a">gContextNextId</a> {0}</td></tr>
<tr class="separator:ad33edc632aa9ec3d78f4a3bd821d342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of context switching that uses the C library's <code>setcontext()</code> methods. </p>
<p>This is intended mostly to be a "test" platform that can be used to verify that the core library works, without relying on assembly other such fun stuff. It's not particularly fast so other platform backends should always be used in preference.</p>
<p>Since we need a place to store the context in addition to the stack, it's stored at the very top of the allocated stack. When allocating the stack internally, this is taken account and some extra space at the top is reserved for it; but this must be kept in mind when using an externally allocated stack, as less (roughly <code>sizeof(ucontext_t)</code> and alignment) space than provided will be actually be available as stack.</p>
<dl class="section note"><dt>Note</dt><dd>Since ucontext has been deprecated since the 2008 revision of POSIX, this may stop working (or not even be supported to begin with) on any given platform in the future. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00029">29</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a67ea909ba16d45b9f6ccfbb5ba29b67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ea909ba16d45b9f6ccfbb5ba29b67c">&#9670;&nbsp;</a></span>AllocMainCothread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UContext::AllocMainCothread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the <a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> instance for the current kernel thread. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8cpp_source.html#l00107">107</a> of file <a class="el" href="UContext_8cpp_source.html">UContext.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                                 {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keyword">auto</span> main = <span class="keyword">new</span> <a class="code" href="classlibcommunism_1_1Cothread.html">Cothread</a>(<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#ad3781a09d44c312e93837b70127c9033">gMainStack</a>, <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#ad3781a09d44c312e93837b70127c9033">gMainStack</a>.data() + <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#affcb29eed86604c5fcbbf229af2d54c9">UContext::kMainStackSize</a>);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#af8323911e50712a84f288c4e54cf97cd">gCurrentHandle</a> = main;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;}</div>
<div class="ttc" id="aclasslibcommunism_1_1Cothread_html"><div class="ttname"><a href="classlibcommunism_1_1Cothread.html">libcommunism::Cothread</a></div><div class="ttdoc">Instance of a single cooperative thread.</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8h_source.html#l00025">Cothread.h:25</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_ad3781a09d44c312e93837b70127c9033"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#ad3781a09d44c312e93837b70127c9033">libcommunism::internal::UContext::gMainStack</a></div><div class="ttdeci">static thread_local std::array&lt; uintptr_t, kMainStackSize &gt; gMainStack</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00104">UContext.h:104</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_af8323911e50712a84f288c4e54cf97cd"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#af8323911e50712a84f288c4e54cf97cd">libcommunism::internal::UContext::gCurrentHandle</a></div><div class="ttdeci">static thread_local Cothread * gCurrentHandle</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00091">UContext.h:91</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_affcb29eed86604c5fcbbf229af2d54c9"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#affcb29eed86604c5fcbbf229af2d54c9">libcommunism::internal::UContext::kMainStackSize</a></div><div class="ttdeci">static constexpr const size_t kMainStackSize</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00078">UContext.h:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a474cfba25de2bbbcecdb6dd3969ba314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474cfba25de2bbbcecdb6dd3969ba314">&#9670;&nbsp;</a></span>ContextFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ucontext_t* libcommunism::internal::UContext::ContextFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the <code>ucontext_t</code> structure for a given cooperative thread.</p>
<p>It's stored at the top of its stack buffer. The actual stack available to the program will be reduced accordingly, but it is still possible for the program to overflow into this structure and wreak havoc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread whose user context struct to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread's user context, in the stack allocation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00052">52</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                                    {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>ucontext_t *<span class="keyword">&gt;</span>(thread-&gt;stack.data());</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b4735f417c02d9d8308180b9398425a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4735f417c02d9d8308180b9398425a">&#9670;&nbsp;</a></span>EntryStub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UContext::EntryStub </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks up the context for the cothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Key into the gContextInfo map </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UContext_8cpp_source.html#l00180">180</a> of file <a class="el" href="UContext_8cpp_source.html">UContext.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                               {</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">// extract info</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    std::unique_ptr&lt;Context&gt; info;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        std::lock_guard&lt;std::mutex&gt; lg(<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a793d056aa4fd1d41300703b6fc65e708">gContextInfoLock</a>);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        info = std::move(<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a0459cebaff39cc99caf4a0d5ae3ec5ac">gContextInfo</a>.at(<span class="keywordtype">id</span>));</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a0459cebaff39cc99caf4a0d5ae3ec5ac">gContextInfo</a>.erase(<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160; </div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="comment">// invoke</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    info-&gt;entry();</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="comment">// call the return handler</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    info.reset();</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a5e82993f5a89feb310864033f1eef279">UContext::InvokeCothreadDidReturnHandler</a>(<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#af8323911e50712a84f288c4e54cf97cd">gCurrentHandle</a>);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a0459cebaff39cc99caf4a0d5ae3ec5ac"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a0459cebaff39cc99caf4a0d5ae3ec5ac">libcommunism::internal::UContext::gContextInfo</a></div><div class="ttdeci">static std::unordered_map&lt; int, std::unique_ptr&lt; Context &gt; &gt; gContextInfo</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00115">UContext.h:115</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a5e82993f5a89feb310864033f1eef279"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a5e82993f5a89feb310864033f1eef279">libcommunism::internal::UContext::InvokeCothreadDidReturnHandler</a></div><div class="ttdeci">static void InvokeCothreadDidReturnHandler(Cothread *from)</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8cpp_source.html#l00170">UContext.cpp:170</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a793d056aa4fd1d41300703b6fc65e708"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a793d056aa4fd1d41300703b6fc65e708">libcommunism::internal::UContext::gContextInfoLock</a></div><div class="ttdeci">static std::mutex gContextInfoLock</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00121">UContext.h:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e82993f5a89feb310864033f1eef279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e82993f5a89feb310864033f1eef279">&#9670;&nbsp;</a></span>InvokeCothreadDidReturnHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UContext::InvokeCothreadDidReturnHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke the return handler. This is put in a separate function so it shows up on the stack trace explicitly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td><a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> that returned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UContext_8cpp_source.html#l00170">170</a> of file <a class="el" href="UContext_8cpp_source.html">UContext.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                                                            {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <a class="code" href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">gReturnHandler</a>(from);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;}</div>
<div class="ttc" id="anamespacelibcommunism_1_1internal_html_a7ffa60f4788d5229f04e2ad5a41b2935"><div class="ttname"><a href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">libcommunism::internal::gReturnHandler</a></div><div class="ttdeci">std::function&lt; void(libcommunism::Cothread *)&gt; gReturnHandler</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8cpp_source.html#l00067">Cothread.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae1d8f0a78ac0c4e87d4eff55cd4bbfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d8f0a78ac0c4e87d4eff55cd4bbfeb">&#9670;&nbsp;</a></span>Prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UContext::Prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Cothread::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepares the <code>ucontext_t</code> buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td><a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> to initialize </td></tr>
    <tr><td class="paramname">entry</td><td>Entry point to execute</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If context allocation or initialization failed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UContext_8cpp_source.html#l00124">124</a> of file <a class="el" href="UContext_8cpp_source.html">UContext.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                                                   {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">// ensure current handle is valid</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">if</span>(!<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#af8323911e50712a84f288c4e54cf97cd">gCurrentHandle</a>) <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a67ea909ba16d45b9f6ccfbb5ba29b67c">UContext::AllocMainCothread</a>();</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160; </div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// build the context structure we pass to our &quot;fake&quot; entry point</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    <span class="keyword">auto</span> info = std::make_unique&lt;Context&gt;(entry);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keywordflow">if</span>(!info) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to allocate context&quot;</span>);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160; </div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="comment">// get its ucontext_t and prepare it</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keyword">auto</span> uctx = <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a474cfba25de2bbbcecdb6dd3969ba314">ContextFor</a>(thread);</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    memset(uctx, 0, <span class="keyword">sizeof</span>(*uctx));</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160; </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">if</span>(getcontext(uctx)) {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;getcontext() failed&quot;</span>);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="comment">// set its stack</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keyword">auto</span> offset = <span class="keyword">sizeof</span>(ucontext_t);</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keywordflow">if</span>(offset % <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a5b5fb08c7e8b373ea1504ff4af4a1c53">kStackAlignment</a>) {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        offset += <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a5b5fb08c7e8b373ea1504ff4af4a1c53">kStackAlignment</a> - (offset % <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a5b5fb08c7e8b373ea1504ff4af4a1c53">kStackAlignment</a>);</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160; </div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    uctx-&gt;uc_stack.ss_sp = <span class="keyword">reinterpret_cast&lt;</span>std::byte *<span class="keyword">&gt;</span>(thread-&gt;stack.data()) + offset;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    uctx-&gt;uc_stack.ss_size = (thread-&gt;stack.size() * <span class="keyword">sizeof</span>(uintptr_t)) - offset;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160; </div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="comment">// store the context in the spicy map</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordtype">int</span> <span class="keywordtype">id</span>{0};</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        std::lock_guard&lt;std::mutex&gt; lg(<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a793d056aa4fd1d41300703b6fc65e708">gContextInfoLock</a>);</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">do</span>{</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="keywordtype">id</span> = ++<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#ad33edc632aa9ec3d78f4a3bd821d342a">gContextNextId</a>;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        } <span class="keywordflow">while</span>(!<span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a0459cebaff39cc99caf4a0d5ae3ec5ac">gContextInfo</a>.emplace(<span class="keywordtype">id</span>, std::move(info));</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160; </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="comment">// fill in the context to invoke the helper method</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="comment">// this is disgusting but it&#39;s C. lol</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    makecontext(uctx, <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span>(*)()<span class="keyword">&gt;</span>(&amp;<a class="code" href="structlibcommunism_1_1internal_1_1UContext.html#a4b4735f417c02d9d8308180b9398425a">EntryStub</a>), 1, <span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a474cfba25de2bbbcecdb6dd3969ba314"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a474cfba25de2bbbcecdb6dd3969ba314">libcommunism::internal::UContext::ContextFor</a></div><div class="ttdeci">static ucontext_t * ContextFor(Cothread *thread)</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00052">UContext.h:52</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a4b4735f417c02d9d8308180b9398425a"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a4b4735f417c02d9d8308180b9398425a">libcommunism::internal::UContext::EntryStub</a></div><div class="ttdeci">static void EntryStub(int id)</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8cpp_source.html#l00180">UContext.cpp:180</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a5b5fb08c7e8b373ea1504ff4af4a1c53"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a5b5fb08c7e8b373ea1504ff4af4a1c53">libcommunism::internal::UContext::kStackAlignment</a></div><div class="ttdeci">static constexpr const size_t kStackAlignment</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00070">UContext.h:70</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_a67ea909ba16d45b9f6ccfbb5ba29b67c"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#a67ea909ba16d45b9f6ccfbb5ba29b67c">libcommunism::internal::UContext::AllocMainCothread</a></div><div class="ttdeci">static void AllocMainCothread()</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8cpp_source.html#l00107">UContext.cpp:107</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1UContext_html_ad33edc632aa9ec3d78f4a3bd821d342a"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1UContext.html#ad33edc632aa9ec3d78f4a3bd821d342a">libcommunism::internal::UContext::gContextNextId</a></div><div class="ttdeci">static int gContextNextId</div><div class="ttdef"><b>Definition:</b> <a href="UContext_8h_source.html#l00126">UContext.h:126</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0459cebaff39cc99caf4a0d5ae3ec5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0459cebaff39cc99caf4a0d5ae3ec5ac">&#9670;&nbsp;</a></span>gContextInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; int, std::unique_ptr&lt; <a class="el" href="structlibcommunism_1_1internal_1_1UContext_1_1Context.html">UContext::Context</a> &gt; &gt; UContext::gContextInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since <code>makecontext()</code> is cursed and only passes parameters of <code>int</code> size of the function, this will break passing a pointer on most 64-bit platforms. Instead, we have this here map that stores an int index, which the entry wrapper pulls out and gets the context from.</p>
<p>The value going into it is based on some counter we increment. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00115">115</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="a793d056aa4fd1d41300703b6fc65e708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793d056aa4fd1d41300703b6fc65e708">&#9670;&nbsp;</a></span>gContextInfoLock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex UContext::gContextInfoLock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex protecting access to the context map. This is taken during insertion and removal of entries in the <a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#ae1d8f0a78ac0c4e87d4eff55cd4bbfeb">Prepare()</a> and entry stubs. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00121">121</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="ad33edc632aa9ec3d78f4a3bd821d342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33edc632aa9ec3d78f4a3bd821d342a">&#9670;&nbsp;</a></span>gContextNextId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int UContext::gContextNextId {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Value of the next integer of the context info map key. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00126">126</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="af8323911e50712a84f288c4e54cf97cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8323911e50712a84f288c4e54cf97cd">&#9670;&nbsp;</a></span>gCurrentHandle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> * UContext::gCurrentHandle {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handle for the currently executing cothread in the calling physical thread. This is updated when switching cothreads, but will be <code>nullptr</code> until the first call to <code>SwitchTo()</code>. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00091">91</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="ad3781a09d44c312e93837b70127c9033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3781a09d44c312e93837b70127c9033">&#9670;&nbsp;</a></span>gMainStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local std::array&lt; uintptr_t, <a class="el" href="structlibcommunism_1_1internal_1_1UContext.html#affcb29eed86604c5fcbbf229af2d54c9">UContext::kMainStackSize</a> &gt; UContext::gMainStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pseudo-stack to use for the "main" cothread, i.e. the native kernel thread executing before a cothread is ever switched to it.</p>
<p>This buffer receives the stack frame of the context of the thread on the first invocation to SwitchTo(). When invoking the Current() method before executing a real cothread, the returned <a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> will correspond to this buffer.</p>
<p>It does not have to be particularly large, since the stack is actually allocated by the system already, and this "stack" only holds the register state. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00104">104</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="afe3bd6961f54c575400fdad9fd858f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3bd6961f54c575400fdad9fd858f16">&#9670;&nbsp;</a></span>kDefaultStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::UContext::kDefaultStackSize {sizeof(uintptr_t) * 0x10000}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default stack size in bytes, if none was requested by the caller. Since this implementation may work on different width architectures, we define this as 64K worth of machine words. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00084">84</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="affcb29eed86604c5fcbbf229af2d54c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcb29eed86604c5fcbbf229af2d54c9">&#9670;&nbsp;</a></span>kMainStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::UContext::kMainStackSize {128}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size of the stack buffer for the "fake" initial cothread, in machine words. This only needs to be large enough to fit the register stack frame. This <em>must</em> be a power of two.</p>
<p>It must be sufficiently large to fit an ucontext_t in it. </p>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00078">78</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<a id="a5b5fb08c7e8b373ea1504ff4af4a1c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5fb08c7e8b373ea1504ff4af4a1c53">&#9670;&nbsp;</a></span>kStackAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::UContext::kStackAlignment {64}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requested alignment for stack allocations.</p>
<p>64 bytes is the most stringent alignment requirements we should probably encounter in the real world (one cache line on most systems) and alignment doesn't result in <em>that</em> much overhead so this is fine.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This must be a power of 2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UContext_8h_source.html#l00070">70</a> of file <a class="el" href="UContext_8h_source.html">UContext.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/arch/ucontext/<a class="el" href="UContext_8h_source.html">UContext.h</a></li>
<li>src/arch/ucontext/<a class="el" href="UContext_8cpp_source.html">UContext.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
