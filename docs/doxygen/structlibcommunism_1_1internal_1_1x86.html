<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcommunism: libcommunism::internal::x86 Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcommunism
   </div>
   <div id="projectbrief">Userspace cooperative threading library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcommunism.html">libcommunism</a></li><li class="navelem"><a class="el" href="namespacelibcommunism_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html">x86</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structlibcommunism_1_1internal_1_1x86-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcommunism::internal::x86 Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Architecture specific methods for working with cothreads on <a class="el" href="structlibcommunism_1_1internal_1_1x86.html" title="Architecture specific methods for working with cothreads on x86 systems.">x86</a> systems.  
 <a href="structlibcommunism_1_1internal_1_1x86.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="x86_2Common_8h_source.html">Common.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86_1_1CallInfo.html">CallInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information required to make a function call for a cothread's entry point.  <a href="structlibcommunism_1_1internal_1_1x86_1_1CallInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0852faf7c3dcbd537f40bbf25a752249"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a0852faf7c3dcbd537f40bbf25a752249">AllocMainCothread</a> ()</td></tr>
<tr class="separator:a0852faf7c3dcbd537f40bbf25a752249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74859bc946ddd893e774d4b6f14fb865"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a74859bc946ddd893e774d4b6f14fb865">ValidateStackSize</a> (const size_t size)</td></tr>
<tr class="separator:a74859bc946ddd893e774d4b6f14fb865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c584c2ea0ca783608b1bad5be610e2"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a92c584c2ea0ca783608b1bad5be610e2">AllocStack</a> (const size_t bytes)</td></tr>
<tr class="separator:a92c584c2ea0ca783608b1bad5be610e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4ad4cee186f1b52019534257668eb9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a4a4ad4cee186f1b52019534257668eb9">DeallocStack</a> (void *stack)</td></tr>
<tr class="separator:a4a4ad4cee186f1b52019534257668eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac714bb8d08d41cedcdf7dbb94d80d343"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#ac714bb8d08d41cedcdf7dbb94d80d343">CothreadReturned</a> ()</td></tr>
<tr class="separator:ac714bb8d08d41cedcdf7dbb94d80d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d507983cf0743cb7b005a0508aefca"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="x86_2Common_8h.html#af4fa632e09ada1dc705345e40ef4e0a3">FASTCALL_TAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#ab7d507983cf0743cb7b005a0508aefca">DereferenceCallInfo</a> (<a class="el" href="structlibcommunism_1_1internal_1_1x86_1_1CallInfo.html">CallInfo</a> *info)</td></tr>
<tr class="separator:ab7d507983cf0743cb7b005a0508aefca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630999a9cee35dfbb7af94c572af2226"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a630999a9cee35dfbb7af94c572af2226">Prepare</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *thread, const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Cothread::Entry</a> &amp;entry)</td></tr>
<tr class="separator:a630999a9cee35dfbb7af94c572af2226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f05a23e6f2d00110c0e19569f114275"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="x86_2Common_8h.html#af4fa632e09ada1dc705345e40ef4e0a3">FASTCALL_TAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a2f05a23e6f2d00110c0e19569f114275">Switch</a> (<a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *from, <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *to)</td></tr>
<tr class="separator:a2f05a23e6f2d00110c0e19569f114275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f67055cd644c94da488c12190be8fd1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a5f67055cd644c94da488c12190be8fd1">JumpToEntry</a> ()</td></tr>
<tr class="separator:a5f67055cd644c94da488c12190be8fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7e95510f8834eb8c01466c5048f09257"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a7e95510f8834eb8c01466c5048f09257">kNumSavedRegisters</a> {4}</td></tr>
<tr class="separator:a7e95510f8834eb8c01466c5048f09257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0849e78f6b329ac0d99f05c2377d3514"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a0849e78f6b329ac0d99f05c2377d3514">kMainStackSize</a> {64}</td></tr>
<tr class="separator:a0849e78f6b329ac0d99f05c2377d3514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ac9a562140d1dbd538017fe0d78d7"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#aa17ac9a562140d1dbd538017fe0d78d7">kStackAlignment</a> {16}</td></tr>
<tr class="separator:aa17ac9a562140d1dbd538017fe0d78d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc7cd52dfc52d39710fc276ee7783a6"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a2fc7cd52dfc52d39710fc276ee7783a6">kDefaultStackSize</a> {0x40000}</td></tr>
<tr class="separator:a2fc7cd52dfc52d39710fc276ee7783a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bc0794e6d5f8750f10dc6ad9446060"><td class="memItemLeft" align="right" valign="top">static thread_local <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#aa1bc0794e6d5f8750f10dc6ad9446060">gCurrentHandle</a> {nullptr}</td></tr>
<tr class="memdesc:aa1bc0794e6d5f8750f10dc6ad9446060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the currently executing cothread (or <code>nullptr</code> til first request for this)  <a href="structlibcommunism_1_1internal_1_1x86.html#aa1bc0794e6d5f8750f10dc6ad9446060">More...</a><br /></td></tr>
<tr class="separator:aa1bc0794e6d5f8750f10dc6ad9446060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e216a93135f6d211d0c096e0914f8d2"><td class="memItemLeft" align="right" valign="top">static thread_local std::array&lt; uintptr_t, <a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a0849e78f6b329ac0d99f05c2377d3514">kMainStackSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a6e216a93135f6d211d0c096e0914f8d2">gMainStack</a></td></tr>
<tr class="separator:a6e216a93135f6d211d0c096e0914f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Architecture specific methods for working with cothreads on <a class="el" href="structlibcommunism_1_1internal_1_1x86.html" title="Architecture specific methods for working with cothreads on x86 systems.">x86</a> systems. </p>
<p>This implementation exploits the fact that clang and GCC both support Microsoft's <a href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-160">fastcall</a> calling convention, so we can get away with one implementation for both System V and Windows platforms, albeit with differing assembly syntaxes.</p>
<p>In operation, this is identical to the <a class="el" href="structlibcommunism_1_1internal_1_1Amd64.html" title="Architecture specific methods for working with cothreads on amd64 based systems.">Amd64</a> implementation; thread state is stored on the stack and the cothread's <code>stackTop</code> pointer actually points to the stack pointer of the cothread when it is switched out. </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00028">28</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0852faf7c3dcbd537f40bbf25a752249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0852faf7c3dcbd537f40bbf25a752249">&#9670;&nbsp;</a></span>AllocMainCothread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void x86::AllocMainCothread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the current physical (kernel) thread's <a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>This will leak the associated cothread object, unless the caller stores it somewhere and ensures they deallocate it later when the underlying kernel thread is destroyed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00076">76</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                            {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keyword">auto</span> main = <span class="keyword">new</span> <a class="code" href="classlibcommunism_1_1Cothread.html">Cothread</a>(<a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a6e216a93135f6d211d0c096e0914f8d2">gMainStack</a>, <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a6e216a93135f6d211d0c096e0914f8d2">gMainStack</a>.data() + <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a0849e78f6b329ac0d99f05c2377d3514">x86::kMainStackSize</a>);</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#aa1bc0794e6d5f8750f10dc6ad9446060">gCurrentHandle</a> = main;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div>
<div class="ttc" id="aclasslibcommunism_1_1Cothread_html"><div class="ttname"><a href="classlibcommunism_1_1Cothread.html">libcommunism::Cothread</a></div><div class="ttdoc">Instance of a single cooperative thread.</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8h_source.html#l00028">Cothread.h:28</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_a0849e78f6b329ac0d99f05c2377d3514"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#a0849e78f6b329ac0d99f05c2377d3514">libcommunism::internal::x86::kMainStackSize</a></div><div class="ttdeci">static constexpr const size_t kMainStackSize</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8h_source.html#l00078">Common.h:78</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_a6e216a93135f6d211d0c096e0914f8d2"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#a6e216a93135f6d211d0c096e0914f8d2">libcommunism::internal::x86::gMainStack</a></div><div class="ttdeci">static thread_local std::array&lt; uintptr_t, kMainStackSize &gt; gMainStack</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8h_source.html#l00094">Common.h:94</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_aa1bc0794e6d5f8750f10dc6ad9446060"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#aa1bc0794e6d5f8750f10dc6ad9446060">libcommunism::internal::x86::gCurrentHandle</a></div><div class="ttdeci">static thread_local Cothread * gCurrentHandle</div><div class="ttdoc">Pointer to the currently executing cothread (or nullptr til first request for this)</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8h_source.html#l00093">Common.h:93</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a92c584c2ea0ca783608b1bad5be610e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c584c2ea0ca783608b1bad5be610e2">&#9670;&nbsp;</a></span>AllocStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * x86::AllocStack </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates memory for a stack that's the given number of bytes in size.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If required (for page alignment, for example) the size may be rounded up.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Size of the stack memory, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If memory allocation failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <em>top</em> of allocated stack </dd></dl>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00103">103</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                                        {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordtype">void</span> *buf{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    buf = _aligned_malloc(bytes, <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#aa17ac9a562140d1dbd538017fe0d78d7">x86::kStackAlignment</a>);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordtype">int</span> err{0};</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    err = posix_memalign(&amp;buf, <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#aa17ac9a562140d1dbd538017fe0d78d7">x86::kStackAlignment</a>, bytes);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">if</span>(err) {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;posix_memalign() failed&quot;</span>);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    }</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">if</span>(!buf) {</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;failed to allocate stack&quot;</span>);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    }</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">return</span> buf;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_aa17ac9a562140d1dbd538017fe0d78d7"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#aa17ac9a562140d1dbd538017fe0d78d7">libcommunism::internal::x86::kStackAlignment</a></div><div class="ttdeci">static constexpr const size_t kStackAlignment</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8h_source.html#l00085">Common.h:85</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac714bb8d08d41cedcdf7dbb94d80d343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac714bb8d08d41cedcdf7dbb94d80d343">&#9670;&nbsp;</a></span>CothreadReturned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void x86::CothreadReturned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The currently running cothread returned from its main function. This is a separate function so that it shows up clearly on stack traces if this causes a crash. </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00139">139</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                           {</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <a class="code" href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">gReturnHandler</a>(<a class="code" href="structlibcommunism_1_1internal_1_1x86.html#aa1bc0794e6d5f8750f10dc6ad9446060">gCurrentHandle</a>);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;}</div>
<div class="ttc" id="anamespacelibcommunism_1_1internal_html_a7ffa60f4788d5229f04e2ad5a41b2935"><div class="ttname"><a href="namespacelibcommunism_1_1internal.html#a7ffa60f4788d5229f04e2ad5a41b2935">libcommunism::internal::gReturnHandler</a></div><div class="ttdeci">std::function&lt; void(libcommunism::Cothread *)&gt; gReturnHandler</div><div class="ttdef"><b>Definition:</b> <a href="Cothread_8cpp_source.html#l00067">Cothread.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a4ad4cee186f1b52019534257668eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4ad4cee186f1b52019534257668eb9">&#9670;&nbsp;</a></span>DeallocStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void x86::DeallocStack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases previously allocated stack memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Pointer to the top of previously allocated stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If deallocating stack fails (invalid pointer) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00127">127</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                                  {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    _aligned_free(stack);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    free(stack);</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7d507983cf0743cb7b005a0508aefca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d507983cf0743cb7b005a0508aefca">&#9670;&nbsp;</a></span>DereferenceCallInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void x86::DereferenceCallInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibcommunism_1_1internal_1_1x86_1_1CallInfo.html">CallInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the call described inside a call info structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Pointer to the call info structure; it's deleted once the call returns. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00148">148</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                                            {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    info-&gt;entry();</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keyword">delete</span> info;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160; </div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="comment">// invoke the return handler; this shouldn&#39;t return</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#ac714bb8d08d41cedcdf7dbb94d80d343">CothreadReturned</a>();</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    std::terminate();</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_ac714bb8d08d41cedcdf7dbb94d80d343"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#ac714bb8d08d41cedcdf7dbb94d80d343">libcommunism::internal::x86::CothreadReturned</a></div><div class="ttdeci">static void CothreadReturned()</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8cpp_source.html#l00139">Common.cpp:139</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f67055cd644c94da488c12190be8fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f67055cd644c94da488c12190be8fd1">&#9670;&nbsp;</a></span>JumpToEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libcommunism::internal::x86::JumpToEntry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pops two words off the stack (for the address of the entry function, and its first register argument) and sets up for a <code>fastcall</code> to that method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is necessary because we can't make a fastcall directly on return from switching as these registers are used by the arguments to the context switch call. </dd></dl>

</div>
</div>
<a id="a630999a9cee35dfbb7af94c572af2226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630999a9cee35dfbb7af94c572af2226">&#9670;&nbsp;</a></span>Prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void x86::Prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibcommunism_1_1Cothread.html#a56facf24195f6223f0fc1397a9a71467">Cothread::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the initial stack frame for a cothread, such that it will return to the entry stub, which then in turn jumps to the context dereferencing handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrap</td><td>Wrapper structure defining the cothread </td></tr>
    <tr><td class="paramname">main</td><td>Entry point for the cothread </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00164">164</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                                            {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    static_assert(offsetof(<a class="code" href="classlibcommunism_1_1Cothread.html">Cothread</a>, stackTop) == COTHREAD_OFF_CONTEXT_TOP, <span class="stringliteral">&quot;cothread stack top is invalid&quot;</span>);</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="comment">// ensure current handle is valid</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">if</span>(!<a class="code" href="structlibcommunism_1_1internal_1_1x86.html#aa1bc0794e6d5f8750f10dc6ad9446060">gCurrentHandle</a>) <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a0852faf7c3dcbd537f40bbf25a752249">x86::AllocMainCothread</a>();</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160; </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="comment">// build the context structure we pass to our entry point stub</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keyword">auto</span> info = <span class="keyword">new</span> CallInfo{entry};</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">if</span>(!info) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to allocate call info&quot;</span>);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="comment">// NOLINTBEGIN(cppcoreguidelines-pro-type-reinterpret-cast)</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="comment">// prepare some space for a stack frame</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keyword">auto</span> &amp;stackBuf = wrap-&gt;stack;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keyword">auto</span> stackFrame = <span class="keyword">reinterpret_cast&lt;</span>std::byte *<span class="keyword">&gt;</span>(stackBuf.data());</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    stackFrame += ((stackBuf.size()*<span class="keyword">sizeof</span>(uintptr_t)) &amp; ~(0x10-1))</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        - (<span class="keyword">sizeof</span>(uintptr_t) * (4 + <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a7e95510f8834eb8c01466c5048f09257">kNumSavedRegisters</a>));</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keyword">auto</span> stack = <span class="keyword">reinterpret_cast&lt;</span>uintptr_t *<span class="keyword">&gt;</span>(stackFrame);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160; </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="comment">// if main returns (it shouldn&#39;t, we call std:;terminate) just crash</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    *--stack = 0;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160; </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="comment">// and then jump to the stub that calls the entry point</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    *--stack = <span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(info);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    *--stack = <span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(&amp;<a class="code" href="structlibcommunism_1_1internal_1_1x86.html#ab7d507983cf0743cb7b005a0508aefca">x86::DereferenceCallInfo</a>);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    *--stack = <span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(&amp;<a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a5f67055cd644c94da488c12190be8fd1">x86::JumpToEntry</a>);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="comment">// NOLINTEND(cppcoreguidelines-pro-type-reinterpret-cast)</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160; </div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="comment">// clear the region that registers are written into (so they&#39;re all zeroed)</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#a7e95510f8834eb8c01466c5048f09257">kNumSavedRegisters</a>; i++) {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        *--stack = 0;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160; </div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="comment">// restore the stack pointer to the correct point</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    wrap-&gt;stackTop = stack;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;}</div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_a0852faf7c3dcbd537f40bbf25a752249"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#a0852faf7c3dcbd537f40bbf25a752249">libcommunism::internal::x86::AllocMainCothread</a></div><div class="ttdeci">static void AllocMainCothread()</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8cpp_source.html#l00076">Common.cpp:76</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_a5f67055cd644c94da488c12190be8fd1"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#a5f67055cd644c94da488c12190be8fd1">libcommunism::internal::x86::JumpToEntry</a></div><div class="ttdeci">static void JumpToEntry()</div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_a7e95510f8834eb8c01466c5048f09257"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#a7e95510f8834eb8c01466c5048f09257">libcommunism::internal::x86::kNumSavedRegisters</a></div><div class="ttdeci">static const size_t kNumSavedRegisters</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8h_source.html#l00070">Common.h:70</a></div></div>
<div class="ttc" id="astructlibcommunism_1_1internal_1_1x86_html_ab7d507983cf0743cb7b005a0508aefca"><div class="ttname"><a href="structlibcommunism_1_1internal_1_1x86.html#ab7d507983cf0743cb7b005a0508aefca">libcommunism::internal::x86::DereferenceCallInfo</a></div><div class="ttdeci">static void FASTCALL_TAG DereferenceCallInfo(CallInfo *info)</div><div class="ttdef"><b>Definition:</b> <a href="x86_2Common_8cpp_source.html#l00148">Common.cpp:148</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f05a23e6f2d00110c0e19569f114275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f05a23e6f2d00110c0e19569f114275">&#9670;&nbsp;</a></span>Switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="x86_2Common_8h.html#af4fa632e09ada1dc705345e40ef4e0a3">FASTCALL_TAG</a> libcommunism::internal::x86::Switch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a context switch.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The implementation of this method is written in assembly and varies slightly depending on the calling convention of the platform (System V vs. Windows.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td><a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> buffer that will receive the current context </td></tr>
    <tr><td class="paramname">to</td><td><a class="el" href="classlibcommunism_1_1Cothread.html" title="Instance of a single cooperative thread.">Cothread</a> buffer whose context is to be restored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74859bc946ddd893e774d4b6f14fb865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74859bc946ddd893e774d4b6f14fb865">&#9670;&nbsp;</a></span>ValidateStackSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void x86::ValidateStackSize </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensures the provided stack size is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of stack, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Stack size is invalid (misaligned, too small, etc.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8cpp_source.html#l00088">88</a> of file <a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                                             {</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">if</span>(!size) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Size may not be nil&quot;</span>);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">if</span>(size % <a class="code" href="structlibcommunism_1_1internal_1_1x86.html#aa17ac9a562140d1dbd538017fe0d78d7">kStackAlignment</a>) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Stack is misaligned&quot;</span>);</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa1bc0794e6d5f8750f10dc6ad9446060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bc0794e6d5f8750f10dc6ad9446060">&#9670;&nbsp;</a></span>gCurrentHandle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local <a class="el" href="classlibcommunism_1_1Cothread.html">Cothread</a> * x86::gCurrentHandle {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the currently executing cothread (or <code>nullptr</code> til first request for this) </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00093">93</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a id="a6e216a93135f6d211d0c096e0914f8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e216a93135f6d211d0c096e0914f8d2">&#9670;&nbsp;</a></span>gMainStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local std::array&lt; uintptr_t, <a class="el" href="structlibcommunism_1_1internal_1_1x86.html#a0849e78f6b329ac0d99f05c2377d3514">x86::kMainStackSize</a> &gt; x86::gMainStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Buffer to store the state of the kernel thread when switching to the first cothread. This only has to be large enough to hold the register context frame, as the stack has been allocated by the system already. </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00094">94</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a id="a2fc7cd52dfc52d39710fc276ee7783a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc7cd52dfc52d39710fc276ee7783a6">&#9670;&nbsp;</a></span>kDefaultStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::x86::kDefaultStackSize {0x40000}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Platform default size to use for the stack, in bytes, if no size is requested by the caller. We default to 256K. </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00091">91</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a id="a0849e78f6b329ac0d99f05c2377d3514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0849e78f6b329ac0d99f05c2377d3514">&#9670;&nbsp;</a></span>kMainStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::x86::kMainStackSize {64}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size of the stack buffer for the "fake" initial cothread, in machine words. This only needs to be large enough to fit the register stack frame. This <em>must</em> be a power of two.</p>
<p>It must be sufficiently large to store the callee-saved general purpose registers </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00078">78</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a id="a7e95510f8834eb8c01466c5048f09257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95510f8834eb8c01466c5048f09257">&#9670;&nbsp;</a></span>kNumSavedRegisters</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t libcommunism::internal::x86::kNumSavedRegisters {4}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of registers saved by the cothread swap code. This is used to correctly build the stack frames during initialization. </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00070">70</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a id="aa17ac9a562140d1dbd538017fe0d78d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17ac9a562140d1dbd538017fe0d78d7">&#9670;&nbsp;</a></span>kStackAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t libcommunism::internal::x86::kStackAlignment {16}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requested alignment for stack allocations.</p>
<p>This is set to only 16 byte alignment as that's the most stringent of any <a class="el" href="structlibcommunism_1_1internal_1_1x86.html" title="Architecture specific methods for working with cothreads on x86 systems.">x86</a> platform. </p>

<p class="definition">Definition at line <a class="el" href="x86_2Common_8h_source.html#l00085">85</a> of file <a class="el" href="x86_2Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/arch/x86/<a class="el" href="x86_2Common_8h_source.html">Common.h</a></li>
<li>src/arch/x86/<a class="el" href="x86_2Common_8cpp_source.html">Common.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
