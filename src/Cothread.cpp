#include <libcommunism/Cothread.h>

#include "AllocImpl.h"
#include "CothreadImpl.h"
#include "CothreadPrivate.h"

#include <exception>
#include <iomanip>
#include <iostream>

/**
 * \mainpage libcommunism Documentation
 *
 * This is the autogenerated documentation for the libcommunism library.
 *
 * \section intro_sec Introduction
 *
 * libcommunism is intended to be a really, really fast, portable, and small implementation of
 * cooperative multithreading in userspace.
 *
 * \subsection license License
 *
 * The library is available under the terms of the ISC License.
 *
 * Copyright (c) 2021 Tristan Seifert
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * \section install-sec Installation
 *
 * The library is typically built as a static library, as there are C++ ABI instability problems
 * with C++ shared libraries on many platforms. However, if you really want to build it as a shared
 * library, set the `BUILD_SHARED` flag when compiling.
 *
 * In all cases, the library is built using CMake. Built it as with any other project; i.e. to get
 * started, from the root directory of the source, execute `mkdir build && cmake ..` for most
 * UNIX-like platforms.
 *
 * \section porting Porting
 *
 * Supporting other architectures and platforms should be relatively trivial. See the
 * \link libcommunism::CothreadImpl cothread implementation class\endlink for an example of the
 * required interaces. In addition, the active platform in use must provide a method to initialize
 * the initial cothread for a given kernel thread.
 *
 * \section more More Information
 *
 * For more information, check out the [project site.](https://libcommunism.blraaz.me/)
 */

namespace libcommunism::internal {
static void DefaultCothreadReturnedHandler(Cothread *);
}

using namespace libcommunism;
using namespace libcommunism::internal;

/**
 * Holds a reference to the cothread termination handler. By default, this prints the thread id of
 * the offending cothread and then kills the process.
 */
std::function<void(Cothread *)> internal::gReturnHandler{DefaultCothreadReturnedHandler};

/**
 * Pointer to the cothread instance that's currently executing on this thread.
 */
thread_local Cothread *Cothread::gCurrent{nullptr};



/**
 * Default handler for a returned cothread
 */
static void libcommunism::internal::DefaultCothreadReturnedHandler(Cothread *thread) {
    std::cerr << "[libcommunism] Cothread $" << std::hex << thread << std::dec;
    if(thread) {
        const auto &label = thread->getLabel();
        if(!label.empty()) {
            std::cerr << " (" << thread->getLabel() << ")";
        } else {
            std::cerr << " (unnamed cothread)";
        }
    }

    std::cerr << " returned from entry point!" << std::endl;
    std::terminate();
}

Cothread::Cothread(const Entry &entry, const size_t stackSize) {
    this->impl = AllocImpl(this->implBuffer, this->implBufferUsed, entry, stackSize);
}

Cothread::Cothread(const Entry &entry, std::span<uintptr_t> stack) {
    this->impl = AllocImpl(this->implBuffer, this->implBufferUsed, entry, stack);
}


Cothread::~Cothread() {
    if(this->implBufferUsed) {
        reinterpret_cast<CothreadImpl *>(this->implBuffer.data())->~CothreadImpl();
    } else {
        delete this->impl;
    }
    this->impl = nullptr;
}

Cothread *Cothread::Current() {
    if(!gCurrent) {
        auto impl = AllocKernelThreadWrapper();
        if(!impl) {
            std::cerr << "failed to allocate kernel cothread wrapper!" << std::endl;
            std::terminate();
        }

        gCurrent = new Cothread(impl);
    }
    return gCurrent;
}

void Cothread::SetReturnHandler(const std::function<void (Cothread *)> &handler) {
    gReturnHandler = handler;
}

void Cothread::ResetReturnHandler() {
    gReturnHandler = DefaultCothreadReturnedHandler;
}

void Cothread::switchTo() {
    auto from = Current()->impl;
    gCurrent = this;
    this->impl->switchTo(from);
}

void *Cothread::getStack() const {
    return this->impl->getStack();
}

size_t Cothread::getStackSize() const {
    return this->impl->getStackSize();
}
